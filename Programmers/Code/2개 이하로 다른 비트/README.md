# 두개 이하로 다른 비트
###### 문제 설명

양의 정수  `x`에 대한 함수  `f(x)`를 다음과 같이 정의합니다.

-   `x`보다 크고  `x`와  **비트가 1~2개 다른**  수들 중에서 제일 작은 수

예를 들어,

-   `f(2) = 3`  입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.

|수|비트|다른 비트의 개수|
|--|--|--|
|2|`000...0010`||
|3|`000...0011`||1|

-   `f(7) = 11`  입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.

|수|비트|다른 비트의 개수|
|--|--|--|--|
|7|`000...0111`||
|8|`000...1000`|4|
|9|`000...1001`|3|
|10|`000...1010`|3|
|11|`000...1011`|2|

정수들이 담긴 배열  `numbers`가 매개변수로 주어집니다.  `numbers`의 모든 수들에 대하여 각 수의  `f`  값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

----------

##### 제한사항

-   1 ≤  `numbers`의 길이 ≤ 100,000
-   0 ≤  `numbers`의 모든 수 ≤ 1015

----------

##### 입출력 예
|numbers|result|
|--|--|
|`[2,7]`|`[3,11]`|

----------

##### 입출력 예 설명

**입출력 예 #1**

-   문제 예시와 같습니다.

##### 실패한 풀이
XOR을 이용해서 입력받은 값을 1씩 증가시면서 비교하려 했는데, 제한사항에 있는 `0 ≤  numbers의 모든 수 ≤ 10^15` 내용을 보면 최대 값이 10^15인데 JS에서 비트로 변경해서 연산할 때 32비트로 처리되어 자리수가 모자르게 되는 현상이 발생했습니다.

##### 풀이
짝수인 경우 가장 오른쪽 비트가 무조건 0이 되기 때문에 1더한 값이 만족하는 값이 되고, 홀수의 경우 규칙을 찾기 위해 정리하면 아래와 같습니다.
|숫자|2진법으로 변경한 값|2비트 다른 값|
|--|--|--|
|7|0111|1011|
|9|1001|1010|
|11|1011|1101|
|13|1101|1110|
|15|1111|10111|
15인 경우를 제외하면 "01" => "10"으로 변경된 모습을 확인할 수 있고, 15에서 2진법으로 변경한 값 가장 오른쪽에 0을 추가해서 생각하면 동일하게 적용되는 점 확인했습니다.

1. 입력받은 값 numbers의 크기만큼 반복하는 반복문을 만든 후 현재 인덱스에 있는 값이 짝수면 +1한 값을 answer 배열에 push하고, 홀수인 경우 2진수로 변경한 값의 가장 왼쪽에 0을 붙인 후 가장 뒤에 있는 "01"의 위치 값을 찾습니다. 가장 마지막 "01"을 기준으로 문자열을 자른 후 "01" 대신 "10"이 들어가도록 문자열을 수정한 후 10진수로 변경하여 answer에 값을 push합니다.

